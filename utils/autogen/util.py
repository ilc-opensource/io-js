import re
from config import *
from termcolor import colored
import globalVar
import os

CURR_MODULE = "-"

summary = {}

def SetPrintModule(m):
  global CURR_MODULE
  CURR_MODULE = m

def UnsetPrintModule():
  global CURR_MODULE
  CURR_MODULE = "-"

def printDbg(str):
  if not DEBUG:
    return

  print colored("[%s][dbg] " % CURR_MODULE + str, "blue")

def printLog(str):
  print colored(str, "green")

def printVerb(str):
  print "[%s][veb] " % CURR_MODULE + str

def printWarn(str):
  print colored("[%s][warn] " % CURR_MODULE + str, "yellow")

def printErr(str):
  print colored("[%s][err] " % CURR_MODULE + str, "red")


reFloat = re.compile('[-+]?[1-9]\d*\.\d*[fF]?|-?0\.\d*[1-9]\d*[fF]?')
reEFloat = re.compile('[-+]?[1-9]\d*\.?\d*[eE][+-]?\d*|-?0\.\d*[1-9]\d*[eE][+-]?\d*')
reHexInt = re.compile('[-+]?0[xX][0-9a-fA-F]+[uU]?[lL]?[lL]?')
reOctInt = re.compile('[-+]?[1-9][0-9]*[uU]?[lL]?[lL]?')
reDecInt = re.compile('[-+]?0[0-7]*[uU]?[lL]?[lL]?')
reString = re.compile('\".*\"|\'.*\'', re.M and re.S)

C2V8 = { \
  "int": ["Int32", "ToInt32", "IntegerValue", "int", "IsInt32"], \
  "unsigned int": ["Uint32", "ToUint32", "Uint32Value", "unsigned int", "IsUint32" ], \
  "long": ["Number", "ToNumber", "NumberValue", "long", "IsNumber" ], \
  "long long": ["Number", "ToNumber", "NumberValue", "long long", "IsNumber" ], \
  "float": ["Number", "ToNumber", "NumberValue", "float", "IsNumber"], \
  "double": ["Number", "ToNumber", "NumberValue", "double", "IsNumber"], \
  "bool" : ["Boolean", "ToBoolean", "BooleanValue", "bool", "IsBoolean"], \
#  "char*": ["v8::String", "ToString", "", "char*", "IsString"] \
}

#link other types
C2V8["char"] = C2V8["int"]
C2V8["short"] = C2V8["int"]
C2V8["byte"] = C2V8["int"]
C2V8["unsigned long"] = C2V8["long"]
C2V8["unsigned long long"] = C2V8["long long"]
C2V8["boolean"] = C2V8["bool"]

C2V8["size_t"] = C2V8["unsigned int"]
#C2V8["uint8_t *"] = C2V8["char*"]

def GetComment():
  global VERSION
  return \
'''/* ----------------------------------------------------------------------------
 * This file was automatically generated by io-js-autogen Version %s
 *
 * Do not make changes to this file unless you know what you are doing--modify the
 * C header file instead.
 * ----------------------------------------------------------------------------- */
''' %(VERSION)

def GetGypComment(gypFileName):
  global VERSION
  return \
'''
# ----------------------------------------------------------------------------
# This file was automatically generated by io-js-autogen Version %s
#
# Do not make changes to this file unless you know what you are doing--modify the
# %s instead.
# -----------------------------------------------------------------------------
''' %(VERSION, gypFileName)

def GetNoQualifierType(t):
  t = t.replace("register ", "")
  t = t.replace("static ", "")
  t = t.replace("const ", "")
  t = t.replace("extern ", "")
  t = t.replace("auto ", "")
  t = t.replace("inline ", "")
  return t

def GetIdenticalType(t):
  t = GetNoQualifierType(t)

  if t.find('''*''') == -1 and t.find('''&''') == -1:
    if t.find("long long") != -1:
      t = "long long"
    elif t.find("long") != -1:
      t = "long"
    elif t.find("unsigned") != -1 or t.find("uint") != -1 or t.find("__u") != -1:
      t = "unsigned int"
    elif t.find("signed") != -1 or t.find("int") != -1 or t.find("__s") != -1:
      t = "int"
  else:
    t = t.replace('''uint8_t''', "char")
    t = t.replace('''__u8''', "char")
    if t.replace(" ","") == "char*":
      t = "char*"

  return t;

def GetV8Type(t):
  if t == "" or t == "void":
    return True

  t = GetIdenticalType(t);  

  if t not in C2V8:
    return False  
  return C2V8[t][0]

def GetConvToCFunc(t):
  t = GetIdenticalType(t);
  return C2V8[t][2]

def GetCValue(value, t):
  t = GetIdenticalType(t);
  if (value):
    s = "%s->%s()" % (value, C2V8[t][2])
  return s

def GetV8Value(value, t):
  t = GetIdenticalType(t);
  return "%s::New(%s)" % (C2V8[t][0], value)

def GetV8TypeCheck(t):
  t = GetIdenticalType(t);
  return C2V8[t][4]

def IsV8FuncGen(func):
  flag = False
  if func["override"]:
    for f in func["funcs"]:
      if CheckSanity(f):
        flag = True;
        break;
  else:
    if CheckSanity(func):
      flag = True;
  return flag

def GetClass(className):
  for f in globalVar.cppHeaders.keys():
    classes = globalVar.cppHeaders[f].classes
    if classes.has_key(className):
      return classes[className]
  raise "Do not find class %d\n" %(className)

def GetBasicType(arg):
  argType = arg["type"]
  if arg.has_key("pointer") and arg["pointer"] == 1 and argType.find("*") != -1:
    starIndex = argType.index("*")
    argBasicType = argType[:starIndex].strip()
  else:
    argBasicType = argType
  return argBasicType

def IsClassArg(argType):
  argType = GetIdenticalType(argType)
  for f in globalVar.cppHeaders.keys():
    classes = globalVar.cppHeaders[f].classes
    if (classes.has_key(argType) and \
          (classes[argType]["declaration_method"] == "class")):
      if globalVar.cppHeaders[f] != globalVar.curCppHeader:
        globalVar.includeFiles.append(f);
      return True
  return False

def IsStructArg(argType):
  argType = GetIdenticalType(argType)
  argType = re.sub(r'^struct ', "", argType);
  for f in globalVar.cppHeaders.keys():
    classes = globalVar.cppHeaders[f].classes
    if (classes.has_key(argType) and \
          ((classes[argType]["declaration_method"] == "struct") or \
           (classes[argType]["declaration_method"] == "typedef") and \
            (classes[argType]["name"] == "struct"))):
      return True
  return False

def IsEnumArg(argType):
  argType = GetIdenticalType(argType)
  argType = re.sub(r'^enum ', "", argType).strip()
  for f in globalVar.cppHeaders.keys():
    enums = globalVar.cppHeaders[f].global_enums
    if enums.has_key(argType):
      return True
  return False

# check sanity of struct
def CheckCommonArgSanity(argType):
  argType = GetIdenticalType(argType)
  if not GetV8Type(argType):
    return False
  return True

# check sanity of Array pointer
def CheckArrayArgSanity(arg):
  argBasicType = GetNoQualifierType(GetBasicType(arg))
  if argBasicType == "void":
    return True
  else:
    return CheckCommonArgSanity(argBasicType)

def CheckEnumArgSanity(arg):
  return True

# check sanity of struct
def CheckStructArgSanity(arg):
  argBasicType = GetNoQualifierType(GetBasicType(arg))
  argStructName = re.sub(r'^struct ', '', argBasicType)
  cls = GetClass(argStructName)
  props = cls["properties"]["public"]
  for idxs, prop in enumerate(props):
    if not CheckArgSanity(prop, False, False):
      return False

  return True

# check sanity of function pointer
def CheckFPArgSanity(arg):
  # only transform simple func pointer
  if not CheckCommonArgSanity(arg["function_pointer"]["rtnType"]["type"]) \
    and not CheckArrayArgSanity(arg["function_pointer"]["rtnType"]) :
    return False
  for argT in arg["function_pointer"]["paraTypes"]:
    if not CheckCommonArgSanity(argT["type"]) \
      and not CheckArrayArgSanity(argT):
      return False
  return True

def CheckArgSanity(arg, convertFP, convertClass):
  argIsArray = 0
  argIsPointer = 0
  if arg.has_key("array"):
    argIsArray = arg["array"]

  if arg.has_key("pointer"):
    argIsPointer = arg["pointer"]

  if (argIsArray + argIsPointer > 1): # only handle one level pointer
    printDbg("arg type: %s (%d level pointer) can't transfer to V8" \
           %(arg["type"], argIsArray + argIsPointer))
    return False

  argBasicType = GetNoQualifierType(GetBasicType(arg))
  if (arg.has_key("function_pointer") and \
      isinstance(arg["function_pointer"], dict) and \
      len(arg["function_pointer"]) > 0) :
    if convertFP:
      return CheckFPArgSanity(arg)
    else:
      return False
  elif IsClassArg(argBasicType):
    return convertClass
  elif (IsStructArg(argBasicType)):
    return CheckStructArgSanity(arg)
  elif (IsEnumArg(argBasicType)):
    return CheckEnumArgSanity(arg)
  elif (argIsArray or argIsPointer):
    return CheckArrayArgSanity(arg)
  else:
    return CheckCommonArgSanity(arg["type"])

def CheckSanity(func):
  if func["pure_virtual"]:
    printDbg("pure virtual function is not allowed")
    return False

  if re.match(r"operator.*", func["name"]):
    printDbg("Func %s is not converted" %(func["name"]))
    return False

  # Check return type
  if not CheckArgSanity(func["rtnType"], False, True):
    printDbg("Func %s return type: %s can't transfer to V8" \
             %(func["name"], func["rtnType"]["type"]))
    return False

  # Check parameters
  for arg in func["parameters"]:
    if not CheckArgSanity(arg, True, True):
      printDbg("Func %s arg type: %s can't transfer to V8" %(func["name"], arg["type"]))
      return False
  return True

def IsEFloat(s):
  m = reEFloat.match(s)
  return m and m.end() == len(s)

def IsFloat(s):
  m = reFloat.match(s)
  return m and m.end() == len(s)

def IsString(s):
  m = reString.match(s)
  return m and m.end() == len(s)

def IsInt(s):
  m = reHexInt.match(s)
  if m and m.end() == len(s):
    return True
  m = reDecInt.match(s)
  if m and m.end() == len(s):
    return True
  m = reOctInt.match(s)
  if m and m.end() == len(s):
    return True
  return False

def IsValidMacro(defines):
  defines = defines.expandtabs(1);
  defines = re.sub(r' +', " ", defines)

  macros = defines.split("//")[0].split(" ", 1)
  if len(macros) != 2:
    return []

  macros[0] = macros[0].strip()
  macros[1] = macros[1].strip()

  if IsInt(macros[1]) or IsString(macros[1]) or IsFloat(macros[1]) or IsEFloat(macros[1]):
    return macros 

  return []

def RemoveLastComma(s):
  return s.rsplit(',', 1)[0]


def AddIndent(s, num):
  indent = " " * num
  lines = s.split("\n")
  for idx, line in enumerate(lines):
    lines[idx] = indent + line
  s = "\n".join(lines)
  return s

def ParseFuncPointTypedef(type_t):
  stack = type_t.split("(", 1);
  if stack[0] != type_t:
    retType = stack[0].strip()
    argTypes = stack[1].split(")", 1)
    if argTypes[0] == stack[1][0:-1]:
      argTypes = argTypes[0].split(",")
      for i in range(len(argTypes)):
        argType = argTypes[i].strip()
        argTypes[i] = {
          "type": argType,
          "pointer" : argType.count("*")
        }
      type_t = { \
        "rtnType" : {
           "type" : retType, \
           "pointer": retType.count("*"), \
#TODO: parse function pointer
           "function_pointer": {}
        },
        "paraTypes": argTypes \
      }
  return type_t

def ParseTypedefs(typedefs):
  for key in typedefs.keys():
    value = re.sub(r" +", " ", typedefs[key])

    funcPointerType = ParseFuncPointTypedef(value)
    if funcPointerType == value:
      valueFP = {
        "function_pointer" : 0, \
        "type" : funcPointerType, \
      }
    else:
      valueFP = {
        "function_pointer" : 1, \
        "type" : funcPointerType, \
      }
    typedefs[key] = valueFP

def GetTypedefVal(argType):
  for f in globalVar.cppHeaders.keys():
    typedefs = globalVar.cppHeaders[f].typedefs
    if typedefs.has_key(argType):
      return typedefs[argType]
  return {}

def ExpandArgTypedef(arg):
  argType = arg["type"]
  typedefVal = GetTypedefVal(argType)
  if typedefVal != {}:
    if typedefVal["function_pointer"] == 1:
      arg["function_pointer"] = typedefVal["type"]
    else:
      arg["type"] = typedefVal["type"]

def ExpandFuncTypedef(func):
  ExpandArgTypedef(func["rtnType"])
  for idx, arg in enumerate(func["parameters"]):
    argType = arg["type"]
    ExpandArgTypedef(arg)

def ExpandTypedef():
  for f in globalVar.cppHeaders.keys():
    cppHeader = globalVar.cppHeaders[f]
    for c in cppHeader.classes:
      for func in cppHeader.classes[c]["methods"]["public"]:
        ExpandFuncTypedef(func)

    for func in cppHeader.functions:
      ExpandFuncTypedef(func)

    for gv in cppHeader.global_vars:
      ExpandArgTypedef(gv)

def ParseFuncPointerParams(params):
  for idx, arg in enumerate(params):
    argType = arg["type"]
    lparenCnt = argType.count("(")
    rparenCnt = argType.count(")")

    if arg["name"] == "" and lparenCnt >= 2 and lparenCnt == rparenCnt:
      lstack = argType.split("(");
      starIndex = lstack[1].find("*")
      if starIndex != -1:
        # get arg name of function pointer
        rparenIndex = lstack[1].find(")")
        params[idx]["name"] = lstack[1][starIndex+1:rparenIndex]

        # get arg type of function pointer
        type_t = lstack[0] + "(" + lstack[2]
        funcPointerType = ParseFuncPointTypedef(type_t)

        if (funcPointerType != type_t):
          params[idx]["function_pointer"] = funcPointerType
        continue

    params[idx]["function_pointer"] = {}

def ParseFuncRtnType(func):
  rtnType = func["rtnType"]
  func["rtnType"] = {
    "type" : rtnType, \
    "pointer": rtnType.count("*"), \
    "array": 0, \
#TODO: parse function pointer
    "function_pointer": {} \
  }

def ParseFuncPoint(cppHeader):
  for c in cppHeader.classes:
    for func in cppHeader.classes[c]["methods"]["public"]:
      ParseFuncPointerParams(func["parameters"])
      ParseFuncRtnType(func)

  for func in cppHeader.functions:
    ParseFuncPointerParams(func["parameters"])
    ParseFuncRtnType(func)

def FixEnumPropType(cppHeader):
  for c in cppHeader.classes:
    enums = cppHeader.classes[c]["enums"]["public"]
    props = cppHeader.classes[c]["properties"]["public"]
    for idx, prop in enumerate(props):
      t = prop["type"]
      for enum in enums:
        if enum["name"] == t:
          cppHeader.classes[c]["properties"]["public"][idx]["type"] = "enum " + t

def mkdir(path):
    path=path.strip()
    path=path.rstrip("\\")

    isExists=os.path.exists(path)

    if not isExists:
        printWarn('Created ' + path)
        os.makedirs(path)
        return True
    else:
        return False

